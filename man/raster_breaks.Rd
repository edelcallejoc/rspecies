% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/raster_breaks.R
\name{raster_breaks}
\alias{aux_foo}
\alias{predict,BinMatScore}
\alias{raster_breaks}
\title{Extract pixels from raster object and breaks it into n bins.}
\usage{
raster_breaks(x.ras, pol.ext, bb = c(t(sp::bbox(pol.ext))), breaks = NULL,
  breaks.by = 0.1)

aux_foo(x, breaks, breaks.by, proj4string = sp::proj4string(x))
}
\arguments{
\item{x.ras}{A \code{raster} object (\code{\link[raster:Raster-class]{RasterLayer}},
\code{\link[raster:Raster-class]{RasterStack}}, \code{\link[raster:Raster-class]{RasterBrick}}).}

\item{pol.ext}{A \code{SpatialPolygonsDataFrame} object. An object from
\code{\link[rspecies]{grd_build}()} is recommended.}

\item{bb}{A integer vector of the form \code{c(min['long'], max['long'],
min['lat'], max['lat'])}. By default \code{bb = c(t(sp::bbox(po.ext)))}.}

\item{breaks}{\code{NULL}, integer or numeric vector. A vector of
length >= 3, indicating the lower limit and upper limit of each bin.
If breaks has length = 3, 2 bins are created. By default \code{breaks = NULL},
if NULL or integer bins are calculated with \code{\link[stats]{quantile}()}.
Se details for further explanation.}

\item{breaks.by}{double. A value between 0 and 1. Argument pass to quantile function, it requires
\code{breaks = NULL}.}
}
\value{
A \code{SpatialPointsDataFrame} object. It includes all raster values and
    its coordinates, and the bin associated.
}
\description{
Take a \code{raster} object (\code{\link[raster:Raster-class]{RasterLayer}},
    \code{\link[raster:Raster-class]{RasterStack}}, \code{\link[raster:Raster-class]{RasterBrick}}),
    and extract pixels values contain by \code{\link[sp]{SpatialPolygonsDataFrame}}
    object. Then, \code{raster_break()} generates bins, given by \code{breaks}
    argument, from pixels values. Finally, it converts all bins into a
    \code{\link[sp]{SpatialPointsDataFrame}} object. See details for further
    explanation
}
\details{
This function extract all pixels values and its coordinates from
    raster object. Valid raster objects are (\code{\link[raster:Raster-class]{RasterLayer}},
    \code{\link[raster:Raster-class]{RasterStack}}, \code{\link[raster:Raster-class]{RasterBrick}}).
    Then, divides values into bins given by \code{breaks} argument. Finally, it
    converts this data into a \code{\link[sp]{SpatialPointsDataFrame}}.

    \code{bb} argument is used for corpping raster object from \code{pol.ext}'
    bounding box. After cropping, cropped raster object is masked into
    \code{pol.ext}' boundaries. Both step are important in order to reduce
    processing time.

    Extraction of values and coordinates are done by \code{\link[raster]{values}} and
    \code{\link[sp]{coordinates}}. Both function are applied to the raster object.
    output is concatenated into \code{data.frame} object.

    \code{breaks} argument can be pass as \code{NULL}, integer or double vector.
    If \code{breaks = NULL}, the bins are calculated trough
    \code{\link[stats]{quantile}(x, probs, na.rm = TRUE)} function,
    where \code{x} argument is \code{values(rasterobj)},
    \code{probs = seq(0, 1, by = breaks.by)}. If \code{breaks = integer} >= 1, the
    bins are calculated in similar way as \code{breaks = NULL}, but
    \code{probs = seq(0, 1, length = (breaks +1))}. If \code{breaks = c()}, where
    a vector of the form \code{c(2.1, 2.5, 2.9)} produce two bins as \code{[2.1, 2.5)}
    and \code{[2.5, 2.9)}. Then the raster values are compared with the range of each bins.
}
\examples{
library(sp)
library(rgeos)
library(raster)

data(Mex0)

# Generating de grid from Mex0 data
Mex0.grd<-grd_build(Mex0)

# Extracting bioclim variables from worldclim
bioclim<-getData('worldclim', var='bio', res=2.5)

# Extracting values from 19 bioclim variables
system.time(bio.sp<-raster_breaks(bioclim, Mex0.grd))
x11()
plot(Mex0.grd)
plot(bio.sp[which(bio.sp$nameID == 'bio1.p01'),], pch = 20,
    col = 'blue', add = TRUE)

# Leaflet interaction

library(leaflet)
leaflet() \%>\%
    addProviderTiles('OpenStreetMap.Mapnik',
        options = providerTileOptions(noWrap = TRUE))\%>\%
    addPolygons(data = Mex0.grd, stroke = TRUE, color = '#FFFFFF',
        layerId = Mex0.grd@data$ID, weight = 1, opacity = 0.3,
        fillColor = '#A9A9A9', fillOpacity = 0.6,
        popup = row.names(Mex0.grd@data)) \%>\%
    addCircleMarkers(data = bio.sp[which(bio.sp$nameID == 'bio1.p01'),],
        radius = 3,
        popup = paste(bio.sp[which(bio.sp$nameID == 'bio1.p01'),]$nameID,
                  bio.sp[which(bio.sp$nameID == 'bio1.p01'),]$val.p, sep = ' '))


# Extracting values from first bioclim variable
system.time(bio1.sp<-raster_breaks(bioclim$bio1, Mex0.grd))

#' # Leaflet interaction

library(leaflet)
library(RColorBrewer)

# Not run, it can take time
pal <- colorFactor('RdYlBu', levels = rev(levels(as.factor(bio1.sp$nameID))))

leaflet() \%>\%
    addProviderTiles('OpenStreetMap.Mapnik',
        options = providerTileOptions(noWrap = TRUE))\%>\%
    addPolygons(data = Mex0.grd, stroke = TRUE, color = '#FFFFFF',
        layerId = Mex0.grd@data$ID, weight = 1, opacity = 0.3,
        fillColor = '#A9A9A9', fillOpacity = 0.6,
        popup = row.names(Mex0.grd@data)) \%>\%
    addCircleMarkers(data = bio1.sp, radius = 1, color = ~pal(bio1.sp$nameID),
        popup = paste(bio1.sp$nameID, bio1.sp$val.p, sep = ' '))

}
\author{
Enrique Del Callejo Canal (\email{edelcallejoc@gmail.com}),
    based on implemented algortihms in web platform SPECIES (see References).
}
\references{
\url{http://species.conabio.gob.mx/}
}

